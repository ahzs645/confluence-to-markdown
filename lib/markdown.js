const { stripTitlePrefix } = require('./utils');

function fixMarkdownTables(markdown) {
  const lines = markdown.split('\n');
  const fixed = [];
  let i = 0;
  const dividerPattern = /^[\s\|\-:]+$/;

  const cleanCell = (cell) => cell
    .replace(/\u00a0/g, ' ')
    .replace(/\s*\n\s*/g, ' ')
    .trim();

  const formatRow = (cells) => `| ${cells.join(' | ')} |`;

  while (i < lines.length) {
    const line = lines[i];
    const nextLine = lines[i + 1];

    if (
      line && line.trim().startsWith('|') &&
      nextLine && nextLine.trim().startsWith('|') &&
      dividerPattern.test(nextLine)
    ) {
      const columnCount = Math.max(0, nextLine.split('|').length - 2);
      if (columnCount === 0) {
        fixed.push(line);
        i += 1;
        continue;
      }

      const headerCells = line.split('|').slice(1, -1).map(cleanCell);
      fixed.push(formatRow(headerCells.map(cell => (cell.length ? cell : ''))));

      const dividerCells = nextLine.split('|').slice(1, -1).map(cell => {
        const trimmed = cell.trim();
        if (!trimmed) {
          return '---';
        }
        const leftAlign = trimmed.startsWith(':');
        const rightAlign = trimmed.endsWith(':');
        const dashCount = trimmed.replace(/[^-]/g, '').length;
        const dashes = '-'.repeat(Math.max(dashCount, 3));
        return `${leftAlign ? ':' : ''}${dashes}${rightAlign ? ':' : ''}`;
      });
      fixed.push(formatRow(dividerCells));

      i += 2;
      let cellBuffer = [];

      while (i < lines.length && lines[i].trim().startsWith('|')) {
        const parts = lines[i].split('|').slice(1, -1);
        for (const part of parts) {
          cellBuffer.push(part);
          if (cellBuffer.length === columnCount) {
            const cleanedCells = cellBuffer.map(cleanCell);
            if (cleanedCells.some(cell => cell.length > 0)) {
              fixed.push(formatRow(cleanedCells.map(cell => (cell.length ? cell : ''))));
            }
            cellBuffer = [];
          }
        }
        i += 1;
      }
      cellBuffer = [];
      continue;
    }

    fixed.push(line);
    i += 1;
  }

  return fixed.join('\n');
}

function cleanupMarkdown(markdown, options = {}) {
  const {
    fixNH = false,
    includeNavigation = true,
    titlePrefixToRemove = null
  } = options;
  let output = markdown;

  output = output.replace(/\n\s*\n\s*\n/g, '\n\n');
  output = output.replace(/\*\*Click here to expand\.\.\.\*\*/g, '');
  output = output.replace(/\*\*Background colour : [A-Za-z]+\*\*/g, '');
  output = output.replace(/!\[\]\(([^)]*bullet[^)]*\.gif)\)\s*\[([^\]]+)\]\(([^)]+)\)\s*\([^)]+\)/g, '![]($1) [$2]($3)');
  output = output.replace(/Document generated by Confluence.*$/gm, '');
  output = output.replace(/\[Atlassian\]\(https?:\/\/www\.atlassian\.com\/?\)/g, '');
  output = output.replace(/\n## Comments:\n(?:\n?\|.*\|\n?)+/g, '\n');
  output = output.replace(/\u00a0/g, ' ');
  output = output.replace(/\u200b/g, '');

  output = fixMarkdownTables(output);

  if (fixNH) {
    output = output.replace(/\\\[NH\\\]/g, '[NH]');
  }

  const lines = output.split('\n').map(line => {
    if (!titlePrefixToRemove) {
      return line;
    }

    const headingMatch = line.match(/^(#+\s+)(.*)$/);
    if (headingMatch) {
      const strippedHeading = stripTitlePrefix(headingMatch[2], titlePrefixToRemove);
      return `${headingMatch[1]}${strippedHeading}`;
    }

    return stripTitlePrefix(line, titlePrefixToRemove);
  });

  const cleanedLines = [];
  const navItems = [];
  let inBreadcrumbs = false;

  const flushNavigation = () => {
    if (!navItems.length) {
      return;
    }

    if (includeNavigation) {
      cleanedLines.push('## Navigation');
      cleanedLines.push('');
      cleanedLines.push(...navItems);
      cleanedLines.push('');
    }

    navItems.length = 0;
  };

  for (let i = 0; i < lines.length; i += 1) {
    const line = lines[i];
    const breadcrumbMatch = line.match(/^\d+\.\s+\[.*\]\(.*\.md\)$/);
    const trimmedLine = line.trim();

    if (breadcrumbMatch) {
      inBreadcrumbs = true;
      navItems.push(line.replace(/^\d+\.\s+/, '- '));
      continue;
    }

    if (inBreadcrumbs) {
      inBreadcrumbs = false;
      flushNavigation();
    }

    if (trimmedLine.toLowerCase().startsWith('created by ')) {
      continue;
    }

    cleanedLines.push(line);
  }

  if (inBreadcrumbs) {
    flushNavigation();
  }

  const trimmed = cleanedLines.join('\n').trim();
  if (!trimmed.length) {
    return '';
  }

  const finalLines = trimmed.split('\n');

  const normalizeForCompare = (value) => value.trim().replace(/\s{2,}$/g, '');

  const firstNonHeadingIndex = finalLines.findIndex(line => {
    const trimmedLine = line.trim();
    if (!trimmedLine.length) {
      return false;
    }
    return !/^#+\s+/.test(trimmedLine);
  });

  const firstH1Index = finalLines.findIndex(line => /^#\s+/.test(line.trim()));

  if (firstNonHeadingIndex !== -1 && firstH1Index !== -1 && firstNonHeadingIndex !== firstH1Index) {
    const firstNonHeading = normalizeForCompare(finalLines[firstNonHeadingIndex]);
    const firstH1 = normalizeForCompare(finalLines[firstH1Index].replace(/^#\s+/, ''));
    if (firstNonHeading && firstNonHeading === firstH1) {
      finalLines.splice(firstNonHeadingIndex, 1);
      if (firstNonHeadingIndex < finalLines.length && finalLines[firstNonHeadingIndex].trim() === '') {
        finalLines.splice(firstNonHeadingIndex, 1);
      }
    }
  }

  const finalOutput = finalLines.join('\n').trim();
  return finalOutput.length ? `${finalOutput}\n` : '';
}

module.exports = {
  cleanupMarkdown,
  fixMarkdownTables
};
